const express = require('express');
const { body, validationResult } = require('express-validator');
const db = require('../db');
const userQueries = require('../db/queries/users');

const router = express.Router();

// Note: Authentication and admin check are handled in index.js

// Get all users
router.get('/users', async (req, res) => {
  try {
    const result = await db.query(userQueries.getAllUsers);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Get user by ID
router.get('/users/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.getUserById,
      [req.params.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// Create user (admin only)
router.post('/users',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('password').trim().isLength({ min: 1, max: 100 }).withMessage('Password is required'),
    body('role').isIn(['admin', 'user']).withMessage('Role must be admin or user'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, password, role } = req.body;

      // Check if user exists
      const existingUser = await db.query(
        userQueries.checkUserExists,
        [name]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({ error: 'User already exists' });
      }

      // Create user (GUID will be auto-generated by database)
      const result = await db.query(
        userQueries.createUser,
        [name, password, role]
      );

      const user = result.rows[0];
      res.status(201).json({
        id: user.id,
        name: user.name,
        role: user.role,
        createdOn: user.createdOn,
      });
    } catch (error) {
      console.error('Error creating user:', error);
      res.status(500).json({ error: 'Failed to create user' });
    }
  }
);

// Delete user (soft delete)
router.delete('/users/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.softDeleteUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already deleted' });
    }

    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// Unlock user account
router.post('/users/:id/unlock', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.unlockUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already unlocked' });
    }

    res.json({ message: 'User unlocked successfully' });
  } catch (error) {
    console.error('Error unlocking user:', error);
    res.status(500).json({ error: 'Failed to unlock user' });
  }
});

// Get all transactions
router.get('/transactions', async (req, res) => {
  try {
    const { userId, limit = 100, offset = 0 } = req.query;
    
    let query = `
      SELECT t."id", t."amount", t."transactionType", t."description", t."createdAt",
             u."id" as "userId", u."name" as "userName",
             creator."name" as "createdByName"
      FROM public.transactions t
      JOIN public.users u ON t."userId" = u."id"
      LEFT JOIN public.users creator ON t."createdBy" = creator."id"
    `;
    
    const params = [];
    if (userId) {
      query += ' WHERE t."userId" = $1';
      params.push(userId);
    }
    
    query += ' ORDER BY t."createdAt" DESC LIMIT $' + (params.length + 1) + ' OFFSET $' + (params.length + 2);
    params.push(parseInt(limit), parseInt(offset));
    
    const result = await db.query(query, params);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching transactions:', error);
    res.status(500).json({ error: 'Failed to fetch transactions' });
  }
});

module.exports = router;
