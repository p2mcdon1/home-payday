const express = require('express');
const { body, validationResult } = require('express-validator');
const db = require('../db');
const userQueries = require('../db/queries/users');
const choreQueries = require('../db/queries/chores');
const effortQueries = require('../db/queries/efforts');
const accountQueries = require('../db/queries/accounts');
const paymentQueries = require('../db/queries/payments');
const withdrawalQueries = require('../db/queries/withdrawals');
const balanceUtils = require('../utils/balance');

const router = express.Router();

// Note: Authentication and adult check are handled in index.js

// Get all users (kids and adults)
router.get('/kids', async (req, res) => {
  try {
    const result = await db.query(userQueries.getAllUsers);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Get user by ID
router.get('/kids/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.getUserById,
      [req.params.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// Get accounts for a user (adult only)
router.get('/kids/:id/accounts', async (req, res) => {
  try {
    const result = await db.query(
      accountQueries.getAccountsByUserId,
      [req.params.id]
    );

    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching user accounts:', error);
    res.status(500).json({ error: 'Failed to fetch user accounts' });
  }
});

// Create user (adult only)
router.post('/kids',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('password').trim().isLength({ min: 1, max: 100 }).withMessage('Password is required'),
    body('role').isIn(['adult', 'kid']).withMessage('Role must be adult or kid'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, password, role, avatar } = req.body;

      // Check if user exists
      const existingUser = await db.query(
        userQueries.checkUserExists,
        [name]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({ error: 'User already exists' });
      }

      // Create user (GUID will be auto-generated by database)
      const result = await db.query(
        userQueries.createUser,
        [name, password, role, avatar]
      );

      const user = result.rows[0];
      res.status(201).json({
        id: user.id,
        name: user.name,
        role: user.role,
        createdOn: user.createdOn,
      });
    } catch (error) {
      console.error('Error creating user:', error);
      res.status(500).json({ error: 'Failed to create user' });
    }
  }
);

// Delete user (soft delete)
router.delete('/kids/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.softDeleteUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already deleted' });
    }

    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// Unlock user account
router.post('/kids/:id/unlock', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.unlockUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already unlocked' });
    }

    res.json({ message: 'User unlocked successfully' });
  } catch (error) {
    console.error('Error unlocking user:', error);
    res.status(500).json({ error: 'Failed to unlock user' });
  }
});

// ===== CHORES ENDPOINTS =====

// Get all chores
router.get('/chores', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllChores);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching chores:', error);
    res.status(500).json({ error: 'Failed to fetch chores' });
  }
});

// Get chore by ID
router.get('/chores/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getChoreById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Chore not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching chore:', error);
    res.status(500).json({ error: 'Failed to fetch chore' });
  }
});

// Create chore
router.post('/chores',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('lifecycleId').isUUID().withMessage('Valid lifecycleId is required'),
    body('rateId').isUUID().withMessage('Valid rateId is required'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, description, link, enabled, lifecycleId, rateId } = req.body;
      const result = await db.query(
        choreQueries.createChore,
        [name.trim(), description || null, link || null, enabled !== undefined ? enabled : true, lifecycleId, rateId]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating chore:', error);
      res.status(500).json({ error: 'Failed to create chore' });
    }
  }
);

// Update chore
router.put('/chores/:id',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('lifecycleId').isUUID().withMessage('Valid lifecycleId is required'),
    body('rateId').isUUID().withMessage('Valid rateId is required'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, description, link, enabled, lifecycleId, rateId } = req.body;
      const result = await db.query(
        choreQueries.updateChore,
        [req.params.id, name.trim(), description || null, link || null, enabled !== undefined ? enabled : true, lifecycleId, rateId]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Chore not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating chore:', error);
      res.status(500).json({ error: 'Failed to update chore' });
    }
  }
);

// Delete chore
router.delete('/chores/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteChore, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Chore not found' });
    }
    res.json({ message: 'Chore deleted successfully' });
  } catch (error) {
    console.error('Error deleting chore:', error);
    res.status(500).json({ error: 'Failed to delete chore' });
  }
});

// ===== LIFECYCLES ENDPOINTS =====

// Get all lifecycles
router.get('/lifecycles', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllLifecycles);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching lifecycles:', error);
    res.status(500).json({ error: 'Failed to fetch lifecycles' });
  }
});

// Get lifecycle by ID
router.get('/lifecycles/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getLifecycleById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Lifecycle not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching lifecycle:', error);
    res.status(500).json({ error: 'Failed to fetch lifecycle' });
  }
});

// Create lifecycle
router.post('/lifecycles',
  [
    body('infinite').isBoolean().withMessage('infinite must be a boolean'),
    body('daily').isBoolean().withMessage('daily must be a boolean'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { infinite, daily, daysOfWeekMask, maxPerDay, maxPerHour } = req.body;
      const result = await db.query(
        choreQueries.createLifecycle,
        [
          infinite || false,
          daily || false,
          daysOfWeekMask || null,
          maxPerDay || null,
          maxPerHour || null
        ]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating lifecycle:', error);
      res.status(500).json({ error: 'Failed to create lifecycle' });
    }
  }
);

// Update lifecycle
router.put('/lifecycles/:id',
  [
    body('infinite').isBoolean().withMessage('infinite must be a boolean'),
    body('daily').isBoolean().withMessage('daily must be a boolean'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { infinite, daily, daysOfWeekMask, maxPerDay, maxPerHour } = req.body;
      const result = await db.query(
        choreQueries.updateLifecycle,
        [
          req.params.id,
          infinite || false,
          daily || false,
          daysOfWeekMask || null,
          maxPerDay || null,
          maxPerHour || null
        ]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Lifecycle not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating lifecycle:', error);
      res.status(500).json({ error: 'Failed to update lifecycle' });
    }
  }
);

// Delete lifecycle
router.delete('/lifecycles/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteLifecycle, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Lifecycle not found' });
    }
    res.json({ message: 'Lifecycle deleted successfully' });
  } catch (error) {
    console.error('Error deleting lifecycle:', error);
    res.status(500).json({ error: 'Failed to delete lifecycle' });
  }
});

// ===== RATES ENDPOINTS =====

// Get all rates
router.get('/rates', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllRates);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching rates:', error);
    res.status(500).json({ error: 'Failed to fetch rates' });
  }
});

// Get rate by ID
router.get('/rates/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getRateById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Rate not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching rate:', error);
    res.status(500).json({ error: 'Failed to fetch rate' });
  }
});

// Create rate
router.post('/rates',
  [],
  async (req, res) => {
    try {
      const { each, formula } = req.body;
      const result = await db.query(
        choreQueries.createRate,
        [each || null, formula || null]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating rate:', error);
      res.status(500).json({ error: 'Failed to create rate' });
    }
  }
);

// Update rate
router.put('/rates/:id',
  [],
  async (req, res) => {
    try {
      const { each, formula } = req.body;
      const result = await db.query(
        choreQueries.updateRate,
        [req.params.id, each || null, formula || null]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Rate not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating rate:', error);
      res.status(500).json({ error: 'Failed to update rate' });
    }
  }
);

// Delete rate
router.delete('/rates/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteRate, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Rate not found' });
    }
    res.json({ message: 'Rate deleted successfully' });
  } catch (error) {
    console.error('Error deleting rate:', error);
    res.status(500).json({ error: 'Failed to delete rate' });
  }
});

// Get pending efforts for adult approval
router.get('/pending-efforts', async (req, res) => {
  try {
    const result = await db.query(effortQueries.getPendingEffortsForAdult);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching pending efforts:', error);
    res.status(500).json({ error: 'Failed to fetch pending efforts' });
  }
});

// Approve effort and create payment
router.post('/efforts/:id/approve', async (req, res) => {
  try {
    const effortId = req.params.id;
    
    // Start transaction by getting effort details
    const effortResult = await db.query(
      `SELECT "id", "choreId", "loggedByUserId", "accountId" 
       FROM public.efforts 
       WHERE "id" = $1 AND "approvedByUserId" IS NULL AND "deniedByUserId" IS NULL`,
      [effortId]
    );

    if (effortResult.rows.length === 0) {
      return res.status(404).json({ error: 'Effort not found or already processed' });
    }

    const effort = effortResult.rows[0];

    // Get chore rate to calculate payment amount
    const choreResult = await db.query(
      `SELECT cr."each", cr."formula" 
       FROM public.chores c
       JOIN public.choreRates cr ON c."rateId" = cr."id"
       WHERE c."id" = $1`,
      [effort.choreId]
    );

    if (choreResult.rows.length === 0) {
      return res.status(404).json({ error: 'Chore not found' });
    }

    const rate = choreResult.rows[0];
    
    // Determine payment amount
    let paymentAmount = 0;
    if (rate.each) {
      paymentAmount = parseFloat(rate.each);
    } else if (rate.formula) {
      // For now, if there's a formula, we'll set amount to 0
      // In a real system, you'd evaluate the formula
      paymentAmount = 0;
    }

    // Determine account - use effort's accountId or get oldest account for user
    let accountId = effort.accountId;
    if (!accountId) {
      const oldestAccountResult = await db.query(
        accountQueries.getOldestAccountByUserId,
        [effort.loggedByUserId]
      );
      
      if (oldestAccountResult.rows.length === 0) {
        return res.status(400).json({ error: 'Kid has no accounts to receive payment' });
      }
      
      accountId = oldestAccountResult.rows[0].id;
    }

    // Approve the effort
    await db.query(effortQueries.approveEffort, [effortId, req.user.id]);

    // Create payment
    const paymentResult = await db.query(
      paymentQueries.createPayment,
      [effortId, accountId, req.user.id, paymentAmount, null]
    );

    // Update balance for the account (aggregate all unbalanced payments/withdrawals)
    let balanceUpdate = null;
    try {
      balanceUpdate = await balanceUtils.updateAccountBalance(accountId);
    } catch (balanceError) {
      console.error('Error updating balance after payment creation:', balanceError);
      // Don't fail the request if balance update fails - payment was created successfully
    }

    res.json({
      effort: { id: effortId, approvedByUserId: req.user.id },
      payment: paymentResult.rows[0],
      balance: balanceUpdate
    });
  } catch (error) {
    console.error('Error approving effort:', error);
    res.status(500).json({ error: 'Failed to approve effort' });
  }
});

// Deny effort
router.post('/efforts/:id/deny', async (req, res) => {
  try {
    const effortId = req.params.id;
    
    const effortResult = await db.query(
      `SELECT "id" FROM public.efforts 
       WHERE "id" = $1 AND "approvedByUserId" IS NULL AND "deniedByUserId" IS NULL`,
      [effortId]
    );

    if (effortResult.rows.length === 0) {
      return res.status(404).json({ error: 'Effort not found or already processed' });
    }

    const result = await db.query(effortQueries.denyEffort, [effortId, req.user.id]);

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error denying effort:', error);
    res.status(500).json({ error: 'Failed to deny effort' });
  }
});

// Update balances for all accounts of a user
router.post('/kids/:id/update-balances', async (req, res) => {
  try {
    const userId = req.params.id;

    // Verify user exists
    const userResult = await db.query(
      userQueries.getUserById,
      [userId]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Get all accounts for this user
    const accountsResult = await db.query(
      accountQueries.getAccountsByUserId,
      [userId]
    );

    if (accountsResult.rows.length === 0) {
      return res.status(400).json({ error: 'Kid has no accounts' });
    }

    const updatedBalances = [];
    const errors = [];

    // Update balance for each account
    for (const account of accountsResult.rows) {
      try {
        const balance = await balanceUtils.updateAccountBalance(account.id);
        if (balance) {
          updatedBalances.push({
            accountId: account.id,
            accountName: account.name,
            balance: balance
          });
        }
      } catch (error) {
        console.error(`Error updating balance for account ${account.id}:`, error);
        errors.push({
          accountId: account.id,
          accountName: account.name,
          error: error.message
        });
      }
    }

    res.json({
      userId,
      userName: userResult.rows[0].name,
      updatedBalances,
      errors: errors.length > 0 ? errors : undefined
    });
  } catch (error) {
    console.error('Error updating balances:', error);
    res.status(500).json({ error: 'Failed to update balances' });
  }
});

// Create withdrawal
router.post('/withdrawals',
  [
    body('accountId').isUUID().withMessage('Valid account ID is required'),
    body('amount').isFloat({ min: 0.01 }).withMessage('Amount must be a positive number'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { accountId, amount, notes } = req.body;

      // Verify account exists
      const accountResult = await db.query(
        accountQueries.getAccountById,
        [accountId]
      );

      if (accountResult.rows.length === 0) {
        return res.status(404).json({ error: 'Account not found' });
      }

      // Create withdrawal
      const withdrawalResult = await db.query(
        withdrawalQueries.createWithdrawal,
        [accountId, req.user.id, parseFloat(amount), notes || null]
      );

      // Update balance for the account (aggregate all unbalanced payments/withdrawals)
      let balanceUpdate = null;
      try {
        balanceUpdate = await balanceUtils.updateAccountBalance(accountId);
      } catch (balanceError) {
        console.error('Error updating balance after withdrawal creation:', balanceError);
        // Don't fail the request if balance update fails - withdrawal was created successfully
      }

      res.status(201).json({
        withdrawal: withdrawalResult.rows[0],
        balance: balanceUpdate
      });
    } catch (error) {
      console.error('Error creating withdrawal:', error);
      res.status(500).json({ error: 'Failed to create withdrawal' });
    }
  }
);

module.exports = router;
