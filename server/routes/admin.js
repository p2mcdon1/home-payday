const express = require('express');
const { body, validationResult } = require('express-validator');
const db = require('../db');
const userQueries = require('../db/queries/users');
const choreQueries = require('../db/queries/chores');

const router = express.Router();

// Note: Authentication and admin check are handled in index.js

// Get all users
router.get('/users', async (req, res) => {
  try {
    const result = await db.query(userQueries.getAllUsers);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Get user by ID
router.get('/users/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.getUserById,
      [req.params.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// Create user (admin only)
router.post('/users',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('password').trim().isLength({ min: 1, max: 100 }).withMessage('Password is required'),
    body('role').isIn(['admin', 'user']).withMessage('Role must be admin or user'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, password, role } = req.body;

      // Check if user exists
      const existingUser = await db.query(
        userQueries.checkUserExists,
        [name]
      );

      if (existingUser.rows.length > 0) {
        return res.status(400).json({ error: 'User already exists' });
      }

      // Create user (GUID will be auto-generated by database)
      const result = await db.query(
        userQueries.createUser,
        [name, password, role]
      );

      const user = result.rows[0];
      res.status(201).json({
        id: user.id,
        name: user.name,
        role: user.role,
        createdOn: user.createdOn,
      });
    } catch (error) {
      console.error('Error creating user:', error);
      res.status(500).json({ error: 'Failed to create user' });
    }
  }
);

// Delete user (soft delete)
router.delete('/users/:id', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.softDeleteUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already deleted' });
    }

    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// Unlock user account
router.post('/users/:id/unlock', async (req, res) => {
  try {
    const result = await db.query(
      userQueries.unlockUser,
      [req.params.id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found or already unlocked' });
    }

    res.json({ message: 'User unlocked successfully' });
  } catch (error) {
    console.error('Error unlocking user:', error);
    res.status(500).json({ error: 'Failed to unlock user' });
  }
});

// ===== CHORES ENDPOINTS =====

// Get all chores
router.get('/chores', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllChores);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching chores:', error);
    res.status(500).json({ error: 'Failed to fetch chores' });
  }
});

// Get chore by ID
router.get('/chores/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getChoreById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Chore not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching chore:', error);
    res.status(500).json({ error: 'Failed to fetch chore' });
  }
});

// Create chore
router.post('/chores',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('lifecycleId').isUUID().withMessage('Valid lifecycleId is required'),
    body('rateId').isUUID().withMessage('Valid rateId is required'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, description, link, enabled, lifecycleId, rateId } = req.body;
      const result = await db.query(
        choreQueries.createChore,
        [name.trim(), description || null, link || null, enabled !== undefined ? enabled : true, lifecycleId, rateId]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating chore:', error);
      res.status(500).json({ error: 'Failed to create chore' });
    }
  }
);

// Update chore
router.put('/chores/:id',
  [
    body('name').trim().isLength({ min: 1, max: 100 }).withMessage('Name must be between 1 and 100 characters'),
    body('lifecycleId').isUUID().withMessage('Valid lifecycleId is required'),
    body('rateId').isUUID().withMessage('Valid rateId is required'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { name, description, link, enabled, lifecycleId, rateId } = req.body;
      const result = await db.query(
        choreQueries.updateChore,
        [req.params.id, name.trim(), description || null, link || null, enabled !== undefined ? enabled : true, lifecycleId, rateId]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Chore not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating chore:', error);
      res.status(500).json({ error: 'Failed to update chore' });
    }
  }
);

// Delete chore
router.delete('/chores/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteChore, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Chore not found' });
    }
    res.json({ message: 'Chore deleted successfully' });
  } catch (error) {
    console.error('Error deleting chore:', error);
    res.status(500).json({ error: 'Failed to delete chore' });
  }
});

// ===== LIFECYCLES ENDPOINTS =====

// Get all lifecycles
router.get('/lifecycles', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllLifecycles);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching lifecycles:', error);
    res.status(500).json({ error: 'Failed to fetch lifecycles' });
  }
});

// Get lifecycle by ID
router.get('/lifecycles/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getLifecycleById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Lifecycle not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching lifecycle:', error);
    res.status(500).json({ error: 'Failed to fetch lifecycle' });
  }
});

// Create lifecycle
router.post('/lifecycles',
  [
    body('infinite').isBoolean().withMessage('infinite must be a boolean'),
    body('daily').isBoolean().withMessage('daily must be a boolean'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { infinite, daily, daysOfWeekMask, maxPerDay, maxPerHour } = req.body;
      const result = await db.query(
        choreQueries.createLifecycle,
        [
          infinite || false,
          daily || false,
          daysOfWeekMask || null,
          maxPerDay || null,
          maxPerHour || null
        ]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating lifecycle:', error);
      res.status(500).json({ error: 'Failed to create lifecycle' });
    }
  }
);

// Update lifecycle
router.put('/lifecycles/:id',
  [
    body('infinite').isBoolean().withMessage('infinite must be a boolean'),
    body('daily').isBoolean().withMessage('daily must be a boolean'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { infinite, daily, daysOfWeekMask, maxPerDay, maxPerHour } = req.body;
      const result = await db.query(
        choreQueries.updateLifecycle,
        [
          req.params.id,
          infinite || false,
          daily || false,
          daysOfWeekMask || null,
          maxPerDay || null,
          maxPerHour || null
        ]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Lifecycle not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating lifecycle:', error);
      res.status(500).json({ error: 'Failed to update lifecycle' });
    }
  }
);

// Delete lifecycle
router.delete('/lifecycles/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteLifecycle, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Lifecycle not found' });
    }
    res.json({ message: 'Lifecycle deleted successfully' });
  } catch (error) {
    console.error('Error deleting lifecycle:', error);
    res.status(500).json({ error: 'Failed to delete lifecycle' });
  }
});

// ===== RATES ENDPOINTS =====

// Get all rates
router.get('/rates', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getAllRates);
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching rates:', error);
    res.status(500).json({ error: 'Failed to fetch rates' });
  }
});

// Get rate by ID
router.get('/rates/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.getRateById, [req.params.id]);
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Rate not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching rate:', error);
    res.status(500).json({ error: 'Failed to fetch rate' });
  }
});

// Create rate
router.post('/rates',
  [],
  async (req, res) => {
    try {
      const { each, formula } = req.body;
      const result = await db.query(
        choreQueries.createRate,
        [each || null, formula || null]
      );

      res.status(201).json(result.rows[0]);
    } catch (error) {
      console.error('Error creating rate:', error);
      res.status(500).json({ error: 'Failed to create rate' });
    }
  }
);

// Update rate
router.put('/rates/:id',
  [],
  async (req, res) => {
    try {
      const { each, formula } = req.body;
      const result = await db.query(
        choreQueries.updateRate,
        [req.params.id, each || null, formula || null]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Rate not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      console.error('Error updating rate:', error);
      res.status(500).json({ error: 'Failed to update rate' });
    }
  }
);

// Delete rate
router.delete('/rates/:id', async (req, res) => {
  try {
    const result = await db.query(choreQueries.deleteRate, [req.params.id]);
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Rate not found' });
    }
    res.json({ message: 'Rate deleted successfully' });
  } catch (error) {
    console.error('Error deleting rate:', error);
    res.status(500).json({ error: 'Failed to delete rate' });
  }
});

module.exports = router;
